\documentclass[preprint]{sigplanconf}

\usepackage[pdftex]{graphicx}
\usepackage[all]{xy}
\usepackage{tikz}
\usetikzlibrary{arrows, shapes, backgrounds, chains, decorations, calc, fit,
    shadows}
\usepackage[english]{babel}
\usepackage[Q=yes]{examplep}
\usepackage{pgf}
\usepackage{tikzuml-v1.0b/tikz-uml}
\usepackage{listings}

\lstset{
  basicstyle=\footnotesize\ttfamily
}

\begin{document}
\title{An Efficient Solution to Work with Large Git Repository}
\authorinfo{Congbin Guo\and Eric Wang}{SCM team, VMware Inc.}{\{cguo,wange\}@vmware.com}
\maketitle
\abstract{
  % the problem
  The lack of partial transferring (e.g. cloning, fetching, or pushing) by subdirectories consumes lots of time and network bandwidth when a Git client talks to a remote repository.
  % why interesting
  This downgrades the development efficiency against many large enterprise level Git repositories, which might have long history or many files.
  % solution
  To support bidirectional transferring by subdirectories specified by a client from a repository, we extends the current Git transfer protocol to allow the selected subdirectories information passed to server, and implement new server side to trim uninterested subdirectories from Git pack file.
  by steps to communicate extra information between server and client side. Furthuremore, we define 
  % value
  The presented extended protocol improves the development efficiency and keeps the Git experience as good as common Git work flows, finally help the Git adoption in enterprises.
}

\keywords
Git, transfer protocol, large repository, pack file, Git object model

\section{Introduction}
%(
% describe the problem
Git is popular but still has problems when work with large remote repositories, which may consume lots of time and network bandwidth in data transferring from, and to, the repository.
The reason is Git store the history of snapshots of whole workspace, which might has tremendous amount of files, especially binary files.
The feature to only transfer subdirectories has been desired for long time.
However, it isn't included in current and recent future release of Git.

% my contribution
In this paper, we present a complete solution to help Git user to work with large repositories:
\begin{itemize}
  \item We analyze the Git transfer protocol first, and extend it to allow subdirectories selection between server and client.
  \item Based on extend protocol, we describe how to minimize the data size to transferred to client by excluding all uninterested objects.
  \item In client side, we talk a way how to create new commits with partial workspace just like in a full cloned workspace.
\end{itemize}

%)
\section{The problem}
%(
Current Git transfer protocol is simple and clear.
The steps of transferring data from server, i.e. cloning or fetching, is shown in Figure \ref{fig:git-proto-clone-seq}:

\begin{enumerate}
  \item Client initiates the request by calling \verb|git-upload-pack| on server.
  \item Server advertises all current reference SHA1s ($H_S$) to the client.
  \item Client sends a list of SHA1 of \verb|want| ($H_w$) and \verb|have| ($H_h$), which indicates the start and end SHA1 of commit objects to be transferred.
    In case of cloning, the list of \verb|have| is skipped since the client has nothing yet.
  \item Server calculates all commit objects (and all other Git objects associated) in range of $[H_w, H_h)$, then writes to a stream connected to the client.
\end{enumerate}

\begin{figure}
  \centering
  \input{figures/git-proto-clone-seq.tikz}
  \caption{Transferring Git objects from server}
  \label{fig:git-proto-clone-seq}
\end{figure}
The steps of transferring data to server, i.e. pushing, is shown in Figure \ref{fig:git-proto-push-seq}:
\begin{enumerate}
  \item Client initiates the request by calling \verb|git-recive-pack| on server.
  \item Serve advertises all current references SHA1s ($H_S$) to the client.
  \item Client calculates all objects (commits and all other associated objects) according to local reference SHA1s ($H_C$) and those advertised by server $H_S$, i.e. $[H_C, H_S)$, packs them and writes to a stream connected to the server.
\end{enumerate}


\begin{figure}
  \centering
  \input{figures/git-proto-push-seq.tikz}
  \caption{Transferring Git objects to server}
  \label{fig:git-proto-push-seq}
\end{figure}

To support subdirectories transferring needs to resolve below problems:
\begin{itemize}
  \item How does server and client negotiate which subdirectories to transfer?
  \item How does server pack Git objects that only included in the chosen subdirectories?
  \item How does client ensure the consistency of newly created commits based on partial workspace?
\end{itemize}
%)

\section{Solution}
We add an optional extra step in the standard transfer protocol to allow subdirectories negotiation between client and server.
The step is initiated by client, so it's transparent for common Git client, which can ensure the server compatibility for all kinds of client.

The extension includes three primitive commands.
\begin{itemize}
  \item \verb|dir| get directory of a SHA1:path.
    this is equivalent to command \verb|git ls-tree SHA1 -- path|.
  \item \verb|include| 
  \item \verb|exclude|
\end{itemize}

\section{The details}

\subsection{Subdirectories negotiation}
Client can send all subdirectories interested and excluded when it has enough information.
Otherwise, the negotiation is necessary.
The subdirectories negotiation is an interactive process because the client may know nothing about the directories, especially in cloning.
\begin{figure}
  \centering
  \input{figures/git-proto-ext-seq.tikz}
  \caption{Extended Git transfer protocol}
  \label{fig:git-proto-ext-seq}
\end{figure}
\subsubsection{Operations}
server response

\subsection{Git Object Model}
\subsection{Server side workflow}
\subsection{Client side workflow}

\section{Related work}

\section{Conclusions and Future works}


\begin{itemize}
  \item  extend the git transferring protocol to allow subdirectories information communicating between server and client side
  \item server side only pack selected subdirectories data and sent it to client side to save resources.
  \item resolve several client side issues to work with this partial pack data files
\end{itemize}

  - extend the transferring protocol to enable it show the directories of the repo
  - describe the steps to select specific subdirectories
  - describe how server side handle the directories and create proper pack files
  - describe how client side create mock blob and tree objects 
  - describe how client create proper commit object based on mocked objects.
- show other technologies which can be combined to use 

We describe the Git transfer protocol first, and then describe how to extended the protocol and the new work flow.
In the tree trim, we present an idea of using empty Git objects as placeholder to make the whole tree object complete.
We resolve an client side issue to create compatible new commit objects by rewriting the commit by a post-commit hook..

\end{document}
