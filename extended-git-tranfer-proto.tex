\documentclass[preprint]{sigplanconf}

\usepackage[pdftex]{graphicx}
\usepackage[all]{xy}
\usepackage{tikz}
\usetikzlibrary{arrows, shapes, backgrounds, chains, decorations, calc, fit,
    shadows}
\usepackage[english]{babel}
\usepackage[Q=yes]{examplep}
\usepackage{pgf}
\usepackage{tikzuml-v1.0b/tikz-uml}
\usepackage{listings}

\lstset{
  basicstyle=\footnotesize\ttfamily
}

\begin{document}
\title{An Efficient Solution to Work with Large Git Repository}
\authorinfo{Congbin Guo\and Eric Wang}{VMware Inc.}{\{cguo,wange\}@vmware.com}
\maketitle
\abstract{
  % the problem
  The lack of partial transferring (e.g. cloning, fetching, or pushing) by subdirectories consumes lots of time and network bandwidth when a Git client talks to a remote repository.
  % why interesting
  This downgrades the development efficiency against many large enterprise level Git repositories, which might have long history or many files.
  % solution
  To support bidirectional transferring by subdirectories specified by a client from a repository, we extends the current Git transfer protocol to allow the selected subdirectories information passed to server, and implement new server side to trim uninterested subdirectories from Git pack file.
  by steps to communicate extra information between server and client side. Furthuremore, we define 
  % value
  The presented extended protocol improves the development efficiency and keeps the Git experience as good as common Git work flows, finally help the Git adoption in enterprises.
}

\keywords
Git, transfer protocol, VCS, pack file, Git object model, spare
clone

\section{Introduction}
%(
% describe the problem
Git is popular but still has problems when work with large remote repositories,
which may consume lots of time and network bandwidth in data transferring from,
and to, the repository.
The reason is Git stores the history of whole workspace snapshots, which may 
have huge amount of directories and files.
The feature to only transfer subdirectories, like other popular VCS systems do
(e.g. Perforce), has been desired for long time.
But it is not in the plan of Git developers, because it may break Git
repository consistency and many Git features.
The suggestion from Git developers to deal with large repository is to break
into small ones, or omit some history by using Git shallow clone.
Neither one is very attractive to enterprise level users.

% my contribution
In this paper, we propose a solution to transfer subdirectories specified by
user from and to remote repositories efficiently.

\begin{itemize}
  \item We analyze the Git transfer protocol first, and extend it to allow
      subdirectories discovery and negotiation between server and client.
  \item Based on the extended protocol, we describe how to optimize the
      transferred data size to client by excluding some Git objects.
  \item More importantly, we discuss how to keep the newly created commits from
      the ``partial'' workspace as consistent as created from a full workspace.
\end{itemize}

%)
\section{Background}
\subsection{Git object model}
Git stores files, directories, and change histories as unique objects, i.e.
\emph{blob} \emph{tree} and \emph{commit}, with names derived from their SHA1
check sum value\cite{gitobj}.
It can be better explained by an example.
Figure \ref{fig:workspace} shows the two snapshots of a sample workspace.
\verb|file1| and \verb|file2| were modified, and a new file \verb|file4| was
added.
\begin{figure}
  \centering
  \input figures/workspace.tikz
  \caption{Snapshots of the sample workspace}
  \label{fig:workspace}
\end{figure}

Figure \ref{fig:git-repo} shows the repository.
Accordingly, there are two commit objects, $C$ and $C'$, with tip $H$ pointing
to the current version, i.e. \verb|HEAD|.
Because \verb|file3| is unchanged, the two commits share blob $B_3$.

\begin{figure}[htpb]
  \centering
  \input{figures/git-model.tikz}
  \caption{Git repository for a sample workspace}
  \label{fig:git-repo}
\end{figure}

\subsection{Git Transfer Protocol}
%(
Current Git transfer protocol is simple and clear\cite{tran-protocol}.
The steps of transferring data from server, i.e. cloning or fetching, is shown in Figure \ref{fig:git-proto-clone-seq}:

\begin{enumerate}
  \item Client initiates the request by calling \verb|git-upload-pack| on server.
  \item Server advertises all current reference SHA1s ($H_S$) to the client.
  \item Client sends a list of SHA1 of \verb|want| ($H_w$) and \verb|have| ($H_h$), which indicates the start and end SHA1 of commit objects to be transferred.
    In case of cloning, the list of \verb|have| is skipped since the client has nothing yet.
  \item Server calculates all commit objects (and all other Git objects associated) in range of $[H_w, H_h)$, then writes to a stream connected to the client.
\end{enumerate}

\begin{figure}
  \centering
  \input{figures/git-proto-clone-seq.tikz}
  \caption{Transferring Git objects from server}
  \label{fig:git-proto-clone-seq}
\end{figure}
The Git transfer protocol also covers the opposite direction, i.e. transfer
data from client to server, also known as pushing.
Because it is fully reused in our solution, we don't describe it in detail
here.

\section{The problem}
To support subdirectories transferring between server and client needs to resolve below problems:
\begin{itemize}
  \item How does server and client negotiate which subdirectories to transfer?
  \item How does server pack Git objects that only included in the chosen subdirectories?
  \item How does client ensure the consistency of newly created commits based on partial workspace?
\end{itemize}
%)

\section{Solution}
Our solution includes both server side and client side changes.
\subsection{Server side}
We add two more steps in server side, one is negotiating subdirectories, another is excluding uninterested objects from packing.
\subsubsection{Subdirectories Negotiation}
Client can send all subdirectories interested and excluded when it has enough information.
Otherwise, the negotiation is necessary.
The subdirectories negotiation is an interactive process because the client may know nothing about the directories, especially in cloning.

We add an extra step in the standard transfer protocol to allow subdirectories negotiation between client and server.
The step is initiated by client, so it's transparent for common Git client, which can ensure the server compatibility for all kinds of client.
\begin{figure}
  \centering
  \input{figures/git-proto-ext-seq.tikz}
  \caption{Extended Git transfer protocol}
  \label{fig:git-proto-ext-seq}
\end{figure}

Operations and server response


The extension includes three primitive commands.
\begin{itemize}
  \item \verb|dir| get directory of a SHA1:path.
    this is equivalent to command \verb|git ls-tree SHA1 -- path|.
    Server returns a list of files or directories under the path specified.
  \item \verb|include| used to specify which subdirectories will be included in result.
  \item \verb|exclude| used to specify which subdirectories should be excluded from result.
\end{itemize}

The BNF of those three commands.
...

\subsubsection{Packing Objects Optimization}
In standard Git protocol, the object packing can be regards as a piped command, i.e.
\begin{verbatim}
git-rev-list|git-pack-objects
\end{verbatim}
That is, get a list of all commits (and its associated objects) first, then pack them.

We try to transfer fewer objects to save time and system resources.
But which objects can be removed from the packing list?
We must keep commit and tag objects for repository consistency.
So only tree and blob objects can be excluded, if they are not in the subdirectories client want.

In the sample repository shown in Figure \ref{fig:git-repo}, suppose the client only want \verb|file1| (represented as $B_1$ and $B'_1$).
The candidate objects for excluding are tree objects ($T_1$ and $T'_1$), and blob objects ($B_2$, $B'_2$, $B_3$ and $B_4$), as highlighted in Figure \ref{fig:find-obj-to-remove}.
\begin{figure}[htpb]
  \centering
  \input{figures/git-model-filtering.tikz}
  \caption{Objects can be excluded in the sample repository}
  \label{fig:find-obj-to-remove}
\end{figure}

After that, we have a reduced object list, and pass that to \verb|git-pack-objects| command to pack.
The whole process can be regarded as a command as:
\begin{verbatim}
git-rev-list|filter($D_i$, $D_e$)|git-pack-objects
\end{verbatim}

\subsection{Client side}
\subsubsection{Packing Objects Receiving}
The pack stream transferred to the client can not be handled by Git directly due to the excluded objects.
We create placeholder files in client for the excluded ones, which we call \emph{Git mock objects}.
The mock objects have same name, i.e. the SHA1 string of the object, as the original objects.
But the content of mock objects is empty.

The reason why we can use empty file as the placeholder is because that Git performs consistency checks based on SHA1 values get from the object file name, rather than re-calculate it again from the content. In other words, Git only cares about the object file name instead of the content.

Figure \ref{fig:cmd-create-mock} shows one way to create empty blob and tree object by command line.
The object file prefixed with \verb|e69de29| and \verb|4b825dc| are the mock blob and tree object we want.
They can play the placeholder to any same type Git object by just renaming it to target SHA1.
The benefits of using those mock objects are:
\begin{enumerate}
  \item They are still Git objects with correct format, though named with SHA1 string of another object.
  \item Their size is small and easy to be created.
  \item An empty tree object can dereference all associated objects, eliminating the need for placeholders for sub-trees and blobs.
\end{enumerate}


\begin{figure}[htpb]
  \centering
  \begin{verbatim}
    # create an empty blob object
    $ :> empty_file
    $ git hash-object -w empty_file
    e69de29bb2d1d6434b8b29ae775ad8c2e48c5391

    # create an empty tree object
    $ git mktree <<EOF
    EOF
    4b825dc642cb6eb9a060e54bf8d69288fbee4904
  \end{verbatim}
  \caption{Command line to create Git mock objects}
  \label{fig:cmd-create-mock}
\end{figure}

Figure \ref{fig:mock-objects} shows the resulting diagram with the mock objects.

\begin{itemize}
  \item The mock object $B_m$ replaces the blob object $B_4$.
  \item The mock tree object $T_m$ and $T'_m$ replace two tree objects, $T_2$ and $T'_2$.
\end{itemize}

\begin{figure}[htpb]
  \centering
  \input{figures/git-model-final.tikz}
  \caption{Replacing Git objects with mock objects}
  \label{fig:mock-objects}
\end{figure}

With those mock objects, Git does not complain anything about the data from the server.

\subsubsection{Workspace Checking-out}
Like normal Git objects, the mock objects can also be checked out to workspace.
The checked-out mock blob objects is a empty file.
And the checked-out mock tree object is nothing.

The checking out of those mock objects can make Git think the current workspace is dirty.
That is because Git recalculates the SHA1 value of working files and compare what recorded in Git index.
Obviously, they are different.

We use \emph{Git sparse checkout} \cite{sparseco} to avoid that, which only
checkout specified subdirectories from repository into workspace.
Here we can reuse the result of subdirectories negotiation done before.
That is what user really want to get initially.



\subsubsection{New Commits Creating}
Git staging area, or \emph{index}, which generally kept in \verb|.git/index|,
is the key data structure for Git to prepare a new commit.
It contains a sorted list of all path names of current tree, each with
permissions and the SHA1 of a blob object \cite{idx-format}.
Git uses the data stored in index to create a tree object, then creates a
commit with that tree.
Even for Git sparse checking out, in which only a part of files be checked
out, the index still contains a full list of all files for committing.

In our case, nothing can be loaded to Git index by reading mock tree objects
since they are empty.
This results in partial Git index which cannot work properly when creating new
commits, which all directories represented by mock tree objects regarded as
removed.

Because it makes no sense for users to modify files out of the scope of
subdirectories negotiated in our solution, we extract missing blob and tree
objects information from the most recent commit, and combine it with data
stored in the Git index to form a complete tree object, then rewrite the commit
to point to the complete tree object.
We do the rewriting just after every new commit created.
Below is the more detail steps:

\begin{enumerate}
  \item Get the tree object content of current version $T_h$, i.e. \\
        \verb|git cat-file -p HEAD^{tree}|.
  \item Get staging files path and SHA1 information $T_t$ from Git index.
  \item Combine the content of $T_h$ and $T_t$ together, then construct a new
        tree object $T$ by command \verb|git mktree|.
  \item Run command \verb|git commit-tree |$T$ to create a new commit object
        $C$.
  \item Update current branch tip to pointed to $C$ by command \\
        \verb|git update-ref|.
\end{enumerate}




\section{The details}
\subsection{The Implementation}
\subsection{Experiment}


\section{Related work}
E. Newren did some inspiring work in \cite{newren10-0}, \cite{newren10-1},
which describes the idea of just clone referenced objects to client side.
Additionally, this work also uses \emph{git replace} mechanism to deal with
commit history.
However, due to modification to cloned commits and index file, some common Git
important operations cannot work perfectly, such as fetch, push, rebase, etc.

N. Duy has also begun to work on sparse clone or subtree clone since 2008; and
who submitted a series of patch in Git community.
\cite{duy08}, \cite{duy10-1}, \cite{duy10-2}, and \cite{duy10-3} describes a
sparse clone method by adding an extra option to \verb|git clone| command, and
rewriting/replacing the commits in clone time.
The work also has pointed out the performance limitation of Git replacement
mechanism.
The weak part of the work is multiple directories cannot be fully supported.

\section{Limitations}
Because of changing in Git object store, the implementation cannot support
any Git operations care about repository, e.g. the command of \verb|fsck|,
\verb|repack|, and \verb|gc|.
Additionally, since the mock tree object is empty, running the command of
\verb|ls-tree| or \verb|cat-file| on that tree object produces empty output.

Another limitation is, since the Git index is partial comparing with normal Git
clone, commands related to Git index may give different results, e.g.
\verb|git ls-files|.





\begin{thebibliography}{10}
    \softraggedright

    \bibitem{sparseco} \emph{Git-read-tree(1) Manual Page} (February
      2013). \newblock URL
      [https://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html]
    \bibitem{roadmap} J. Hamano (July 2008). \newblock \emph{sparse fetch}.
    \newblock Git mailing list. \newblock URL
      [http://thread.gmane.org/gmane.comp.version-control.git/89681/focus=90016]
    \bibitem{gitobj} S. Chacon (July 2009).\newblock\emph{Pro Git}, section 9.2.
      \newblock URL
      [http://git-scm.com/book/en/Git-Internals-Git-Objects]
      \bibitem{idx-format} \emph{GIT index format}.\newblock URL
      https://www.kernel.org/pub/software/scm/git/docs/technical/index-format.txt
    \bibitem{packformat} \emph{GIT pack format}.\newblock URL
      [https://www.kernel.org/pub/software/scm/git/docs/technical/pack-format.txt]
    \bibitem{replace} \emph{git-replace(1) Manual Page} (February 2013).\newblock
      URL [https://www.kernel.org/pub/software/scm/git/docs/git-replace.html]
    \bibitem{tran-protocol} \emph{Pack files transfer protocol}.\newblock URL
      [https://www.kernel.org/pub/software/scm/git/docs/v1.7.0.5/technical/\\
      pack-protocol.txt]
    \bibitem{duy08}N. Duy (July 2008).\newblock \emph{git-clone: support --path
      to do sparse clone}. \newblock Git mailing list. \newblock URL
      [http://article.gmane.org/gmane.comp.version-control.git/89681]
    \bibitem{newren10-0}E. Newren (July 2010). \newblock \emph{Sparse clones}.
      \newblock Git mailing list. \newblock URL
      http://article.gmane.org/gmane.comp.version-control.git/152020
    \bibitem{newren10-1}E. Newren (September 2010). \newblock \emph{Sparse
      clones}.  \newblock Git mailing list. \newblock URL
      http://article.gmane.org/gmane.comp.version-control.git/155389
    \bibitem{duy10-1}N. Duy (July 2010). \newblock \emph{Subtree clone?}. \newblock
      Git mailing list. \newblock URL
      [http://article.gmane.org/gmane.comp.version-control.git/151937]
    \bibitem{duy10-2}N. Duy (July 2010). \newblock \emph{Subtree clone proof of
    concept}. \newblock Git mailing list. \newblock URL
    [http://article.gmane.org/gmane.comp.version-control.git/152347].
    \bibitem{duy10-3}N. Duy (August 2010). \newblock \emph{subtree clone v2}.
    \newblock Git mailing list. \newblock
    URL [http://article.gmane.org/gmane.comp.version-control.git/154343].
\end{thebibliography}

\end{document}

