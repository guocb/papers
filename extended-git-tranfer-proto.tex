\documentclass[preprint]{sigplanconf}

\usepackage[pdftex]{graphicx}
\usepackage[all]{xy}
\usepackage{tikz}
\usetikzlibrary{arrows, shapes, backgrounds, chains, decorations, calc, fit,
    shadows}
\usepackage[english]{babel}
\usepackage[Q=yes]{examplep}
\usepackage{pgf}
\usepackage{tikzuml-v1.0b/tikz-uml}
\usepackage{listings}

\lstset{
  basicstyle=\footnotesize\ttfamily
}

\begin{document}
\title{An Efficient Solution to Work with Large Git Repository}
\authorinfo{Congbin Guo\and Eric Wang}{SCM team, VMware Inc.}{\{cguo,wange\}@vmware.com}
\maketitle
\abstract{
  % the problem
  The lack of partial transferring (e.g. cloning, fetching, or pushing) by subdirectories consumes lots of time and network bandwidth when a Git client talks to a remote repository.
  % why interesting
  This downgrades the development efficiency against many large enterprise level Git repositories, which might have long history or many files.
  % solution
  To support bidirectional transferring by subdirectories specified by a client from a repository, we extends the current Git transfer protocol to allow the selected subdirectories information passed to server, and implement new server side to trim uninterested subdirectories from Git pack file.
  by steps to communicate extra information between server and client side. Furthuremore, we define 
  % value
  The presented extended protocol improves the development efficiency and keeps the Git experience as good as common Git work flows, finally help the Git adoption in enterprises.
}

\keywords
Git, transfer protocol, large repository, pack file, Git object model

\section{Introduction}
%(
% describe the problem
Git is popular but still has problems when work with large remote repositories, which may consume lots of time and network bandwidth in data transferring from, and to, the repository.
The reason is Git store the history of snapshots of whole workspace, which might has tremendous amount of files, especially binary files.
The feature to only transfer subdirectories has been desired for long time.
However, it isn't included in current and recent future release of Git.

% my contribution
In this paper, we present a complete solution to help Git user to work with large repositories:
\begin{itemize}
  \item We analyze the Git transfer protocol first, and extend it to allow subdirectories selection between server and client.
  \item Based on extend protocol, we describe how to minimize the data size to transferred to client by excluding all uninterested objects.
  \item In client side, we talk a way how to create new commits with partial workspace just like in a full cloned workspace.
\end{itemize}

%)
\section{The problem}
%(
Current Git transfer protocol is simple and clear.
The steps of transferring data from server, i.e. cloning or fetching, is shown in Figure \ref{fig:git-proto-clone-seq}:

\begin{enumerate}
  \item Client initiates the request by calling \verb|git-upload-pack| on server.
  \item Server advertises all current reference SHA1s ($H_S$) to the client.
  \item Client sends a list of SHA1 of \verb|want| ($H_w$) and \verb|have| ($H_h$), which indicates the start and end SHA1 of commit objects to be transferred.
    In case of cloning, the list of \verb|have| is skipped since the client has nothing yet.
  \item Server calculates all commit objects (and all other Git objects associated) in range of $[H_w, H_h)$, then writes to a stream connected to the client.
\end{enumerate}

\begin{figure}
  \centering
  \input{figures/git-proto-clone-seq.tikz}
  \caption{Transferring Git objects from server}
  \label{fig:git-proto-clone-seq}
\end{figure}
The steps of transferring data to server, i.e. pushing, is shown in Figure \ref{fig:git-proto-push-seq}:
\begin{enumerate}
  \item Client initiates the request by calling \verb|git-recive-pack| on server.
  \item Serve advertises all current references SHA1s ($H_S$) to the client.
  \item Client calculates all objects (commits and all other associated objects) according to local reference SHA1s ($H_C$) and those advertised by server $H_S$, i.e. $[H_C, H_S)$, packs them and writes to a stream connected to the server.
\end{enumerate}


\begin{figure}
  \centering
  \input{figures/git-proto-push-seq.tikz}
  \caption{Transferring Git objects to server}
  \label{fig:git-proto-push-seq}
\end{figure}

To support subdirectories transferring needs to resolve below problems:
\begin{itemize}
  \item How does server and client negotiate which subdirectories to transfer?
  \item How does server pack Git objects that only included in the chosen subdirectories?
  \item How does client ensure the consistency of newly created commits based on partial workspace?
\end{itemize}
%)

\section{Solution}
\subsection{Subdirectories negotiation}
Client can send all subdirectories interested and excluded when it has enough information.
Otherwise, the negotiation is necessary.
The subdirectories negotiation is an interactive process because the client may know nothing about the directories, especially in cloning.

We add an extra step in the standard transfer protocol to allow subdirectories negotiation between client and server.
The step is initiated by client, so it's transparent for common Git client, which can ensure the server compatibility for all kinds of client.
\begin{figure}
  \centering
  \input{figures/git-proto-ext-seq.tikz}
  \caption{Extended Git transfer protocol}
  \label{fig:git-proto-ext-seq}
\end{figure}
\subsubsection{Operations}
server response


The extension includes three primitive commands.
\begin{itemize}
  \item \verb|dir| get directory of a SHA1:path.
    this is equivalent to command \verb|git ls-tree SHA1 -- path|.
    Server returns a list of files or directories under the path specified.
  \item \verb|include| used to specify which subdirectories will be included in result.
  \item \verb|exclude| used to specify which subdirectories should be excluded from result.
\end{itemize}

The BNF of those three commands.
...

\subsection{Objects packing}
\subsubsection{Git Object Model}
Git stores files, directories, and change histories as unique objects with names derived from their SHA1 check sum value\cite{gitobj}.
There are four types of objects in Git object model, i.e. \emph{commit}, \emph{tree}, \emph{blob}, and \emph{tag}.
The Git object model can best be explained by example.
Figure \ref{fig:workspace} shows the two snapshots of a sample workspace.
The changes made include:
\begin{itemize}
  \item modifies \verb|file1| and \verb|file2|
  \item adds a new file \verb|file4| in directory \verb|dir1/|
\end{itemize}
\begin{figure}
  \centering
  \input figures/workspace.tikz
  \caption{Snapshots of the sample workspace}
  \label{fig:workspace}
\end{figure}

The repository now stores two versions of the workspace.
Figure \ref{fig:git-repo} shows them as commit objects, $C$ and $C'$, with tip $H$ pointing to the current version, \verb|HEAD|.
Because \verb|file3| is unchanged, the two commits share blob $B_3$.

\begin{figure}[htpb]
  \centering
  \input{figures/git-model.tikz}
  \caption{Git repository for a sample workspace}
  \label{fig:git-repo}
\end{figure}

\subsubsection{packing}
In standard Git protocol, the object packing can be regards as a piped command, i.e. \verb|git-object-list|git-pack-objects|.
That is, get a list of all commits (and its associated objects) first, then pack them.

In our solution, we remove all tree object and blob object which not in the subdirectories client specified, and then pass the reduced list to pack command.

The whole process can be regarded as a command as \verb|git-object-list\|filter($D_i$, $D_e$)\|git-pack-objects|.

\subsubsection{Mock Objects}
the pack file transferred to the client can not be handled by Git directly because many objects are removed.
The Git object chain is broken, and we must add some \emph{mock} Git objects to complete it.

\subsection{Client side commits rewriting}
The \emph{index} is one key data structure for Git, which loads current workspace as a staging area, and prepares for new commit to be created.
In our case, only some subdirectories of the repository is cloned, so the index is partial, which result in new commits created is partial as well.
Therefore, we must rewrite them to complete all missing subdirectories information before those pushed to server.

The rewriting can be done either at client side or server side.
The simplest way may be done by a \verb|post-commit| hook, which called every time a commit created.
In this hook, we complete the missing subdirectories information to the tree object associated with the commit, and create a new commit to replace current one.




\section{The details}


\section{Related work}

\section{Conclusions and Future works}


\begin{itemize}
  \item  extend the git transferring protocol to allow subdirectories information communicating between server and client side
  \item server side only pack selected subdirectories data and sent it to client side to save resources.
  \item resolve several client side issues to work with this partial pack data files
\end{itemize}

  - extend the transferring protocol to enable it show the directories of the repo
  - describe the steps to select specific subdirectories
  - describe how server side handle the directories and create proper pack files
  - describe how client side create mock blob and tree objects 
  - describe how client create proper commit object based on mocked objects.
- show other technologies which can be combined to use 

We describe the Git transfer protocol first, and then describe how to extended the protocol and the new work flow.
In the tree trim, we present an idea of using empty Git objects as placeholder to make the whole tree object complete.
We resolve an client side issue to create compatible new commit objects by rewriting the commit by a post-commit hook..

\begin{thebibliography}{10}
    \softraggedright

    \bibitem{sparseco} \emph{Git-read-tree(1) Manual Page} (February
      2013). \newblock URL
      [https://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html]
    \bibitem{roadmap} J. Hamano (July 2008). \newblock \emph{sparse fetch}.
    \newblock Git mailing list. \newblock URL
      [http://thread.gmane.org/gmane.comp.version-control.git/89681/focus=90016]
    \bibitem{gitobj} S. Chacon (July 2009).\newblock\emph{Pro Git}, section 9.2.
      \newblock URL
      [http://git-scm.com/book/en/Git-Internals-Git-Objects]
      \bibitem{idx-format} \emph{GIT index format}.\newblock URL
      https://www.kernel.org/pub/software/scm/git/docs/technical/index-format.txt
    \bibitem{packformat} \emph{GIT pack format}.\newblock URL
      [https://www.kernel.org/pub/software/scm/git/docs/technical/pack-format.txt]
    \bibitem{replace} \emph{git-replace(1) Manual Page} (February 2013).\newblock
      URL [https://www.kernel.org/pub/software/scm/git/docs/git-replace.html]
    \bibitem{tran-protocol} \emph{Pack files transfer protocol}.\newblock URL
      [https://www.kernel.org/pub/software/scm/git/docs/v1.7.0.5/technical/\\
      pack-protocol.txt]
    \bibitem{duy08}N. Duy (July 2008).\newblock \emph{git-clone: support --path
      to do sparse clone}. \newblock Git mailing list. \newblock URL
      [http://article.gmane.org/gmane.comp.version-control.git/89681]
    \bibitem{newren10-0}E. Newren (July 2010). \newblock \emph{Sparse clones}.
      \newblock Git mailing list. \newblock URL
      http://article.gmane.org/gmane.comp.version-control.git/152020
    \bibitem{newren10-1}E. Newren (September 2010). \newblock \emph{Sparse
      clones}.  \newblock Git mailing list. \newblock URL
      http://article.gmane.org/gmane.comp.version-control.git/155389
    \bibitem{duy10-1}N. Duy (July 2010). \newblock \emph{Subtree clone?}. \newblock
      Git mailing list. \newblock URL
      [http://article.gmane.org/gmane.comp.version-control.git/151937]
    \bibitem{duy10-2}N. Duy (July 2010). \newblock \emph{Subtree clone proof of
    concept}. \newblock Git mailing list. \newblock URL
    [http://article.gmane.org/gmane.comp.version-control.git/152347].
    \bibitem{duy10-3}N. Duy (August 2010). \newblock \emph{subtree clone v2}.
    \newblock Git mailing list. \newblock
    URL [http://article.gmane.org/gmane.comp.version-control.git/154343].
\end{thebibliography}

\end{document}
