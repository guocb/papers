\documentclass[final]{beamer}
\setbeamertemplate{caption}[numbered]
\usepackage[orientation=portrait, size=custom, width=60.96, height=91.44]{beamerposter}
\usepackage{tikz}
\usetikzlibrary{arrows, shapes, backgrounds, chains, decorations, calc, fit, shadows}
\usepackage{pgf}
\usepackage{tikzuml-v1.0b/tikz-uml}
\usepackage{scalefnt}
\mode<presentation>{\usetheme{Radio}}


\title{Bidirectional Git Objects Transferring\\ by Subdirectories Specified}
\author{Congbin Guo \& Eric Wang \{cguo,wange\}@vmware.com}
\institute{SCM Team, VMware Inc.}
\logo{\includegraphics[scale=4]{figures/VMwareLogo}}

\begin{document}
\begin{frame}[t, fragile]
  \begin{columns}[t]
    \begin{column}{.49\linewidth}
      \begin{block}{Abstract}
        \input abstract.input
      \end{block}
      \begin{block}{Problems}
\begin{itemize}
    \justifying
  \item How does the client discover the subdirectories and negotiate with
      the server which to be transferred?

  \item How does the server optimize the Git object pack file according to the
      selected subdirectories?

  \item How does the client operate with the partial Git object store and
      ensure the newly created commits are equivalant as the ones
      from the complete Git object store?
\end{itemize}
      \end{block}
      \begin{block}{Git Object Model \& Transfer Protocol}
        \begin{columns}[T]
          \begin{column}{.47\textwidth}
              \begin{figure}\centering
                \resizebox{\textwidth}{!}{
                  \includegraphics{figures/workspace}
                }
                \caption{Snapshots of the example workspace}
              \end{figure}
            Current Git transfer protocol:
\begin{enumerate}
    \justifying
  \item Client initiates the request by calling \verb|git-upload-pack| on
    server.

  \item Server advertises all current reference SHA1s ($H_s$) to the client.

  \item Client sends a list of SHA1 of \verb|want| ($H_w$) and \verb|have|
    ($H_h$), which indicates the start and end SHA1 of commit objects to be
    transferred.
    In case of cloning, the list of \verb|have| is skipped since the client has
    nothing yet.

  \item Server calculates all commit objects (and all other Git objects
    associated) in range of $[H_w, H_h)$, then writes to a stream connected to
    the client.
\end{enumerate}
          \end{column}
          \begin{column}{.5\textwidth}
              \begin{figure}\centering
                \resizebox{\textwidth}{!}{
                  \includegraphics{figures/git-model-base}
                }
                \caption{Git repository for an example workspace}
              \end{figure}
            \begin{figure} \centering
              \resizebox{\textwidth}{!}{
                \includegraphics{figures/git-proto-clone-seq.pdf}
              }
              \caption{Current Git Transfer Protocol}
            \end{figure}
          \end{column}
        \end{columns}
      \end{block}
      \begin{block}{Extended Git Transfer Protocol}

        \begin{columns}[T]
          \begin{column}{.5\textwidth}
\begin{itemize}
    \justifying
  \item Negotiating Subdirectories
    \begin{enumerate}
  \item \verb|dir| get a list of files and directories under \verb|path| of a
    \verb|SHA1| (equivalent to \verb|git ls-tree SHA1 -- path|).

  \item \verb|include| specify files or subdirectories to be included in data
    transferring.

  \item \verb|exclude| specify files or subdirectories to be excluded from data
    transferring.
      \end{enumerate}
\end{itemize}
              \begin{figure} \centering
                \resizebox{1\textwidth}{!}{
                  \includegraphics{figures/git-model-filtering.pdf}
                }
                \caption{Objects excluded in the repository}
              \end{figure}
\end{column}
          \begin{column}{.5\textwidth}
            \begin{figure} \centering
              \resizebox{\textwidth}{!}{
                \includegraphics{figures/git-proto-ext-seq.pdf}
              }
              \caption{Extended Git transfer protocol}
            \end{figure}
            \begin{itemize}
              \item Optimizing Git Object Packing
    \begin{enumerate}
  \item We keep tag and commit objects.

  \item We remove blob and tree objects in case the files or directories they
    represent are not in the subdirectories specified.
\end{enumerate}
            \end{itemize}
          \end{column}
        \end{columns}

      \end{block}
    \end{column}
    \begin{column}{.49\linewidth}
      \begin{block}{Git Client Side Extensions}
        \begin{columns}[T]
            \begin{column}{.5\textwidth}
\begin{itemize}
  \justifying
  \item Receiving Objects
    \begin{itemize}
      \item \emph{Git Mock Object} is a client side Git object file with
        \textbf{EMPTY} content.
    \end{itemize}
  \item Checking out workspace
    \begin{itemize}
    \item We use \emph{Git sparse checkout} to checkout specified
      subdirectories from repository into workspace.
    \end{itemize}
  \item Creating new commits
\begin{enumerate}
  \item Get the tree object content of current version $T_h$, i.e. \\
        \verb|git cat-file -p HEAD^{tree}|.

  \item Get staging files path and SHA1 information $T_t$ from Git index.

  \item Combine the content of $T_h$ and $T_t$ together; and then construct a
        new tree object $T$ by command \verb|git mktree|.

  \item Run command \verb|git commit-tree |$T$ to create a new commit object
        $C$.

  \item Update current branch tip to pointed to $C$ by command
    \verb|git update-ref|.
\end{enumerate}
\end{itemize}

\end{column}
          \begin{column}{.5\textwidth}
              \begin{figure} \centering
                \resizebox{1\textwidth}{!}{
                  \includegraphics{figures/git-model-final.pdf}
                }
                \caption{Replacing Git objects with mock objects}
              \end{figure}
              \begin{itemize}
                \item Commands to create Git mock objects:
              \end{itemize}
\begin{verbatim}
  # create an empty blob object
  $ :> emptyfile
  $ git hash-object -w emptyfile
  e69de29...48c5391

  # create an empty tree object
  $ git mktree <<EOF
  EOF
  4b825dc...bee4904
\end{verbatim}
            \end{column}
\end{columns}
      \end{block}
      \begin{block}{System Implementation}
              \begin{figure} \centering
                \resizebox{.85\textwidth}{!}{
                  \includegraphics{figures/components.pdf}
                }
                \caption{System level components}
              \end{figure}
\begin{itemize}
    \justifying
  \item \emph{Subdirs} communicates with client to track which subdirectories
    of the repository to be transferred.

  \item \emph{Filter} gets the objects list from
    \verb|git rev-list| command, and filters them by subdirectories specified.

  \item \emph{Mock object builder} accepts the mock object list
    from the filter, and then create mock objects accordingly.

  \item \emph{Commit creator} creates new commits and ensures
    the tree object of commit is complete as described.
\end{itemize}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}
\end{document}
